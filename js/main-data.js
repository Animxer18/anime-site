// * Задача №1: Выведем топ-5 просматриваемых аниме. * \\
// * Задача №2: Разделить получаемые из БД данные на жанры и в каждом жанре вывести лишь те аниме-фильмы, что ему принадлежат, по 6 элементов для каждого. * \\
// * Задача №3: Сделать функционал, чтобы были разные категории в выпадающем меню в хедере и можно было перейти по каждой категории фильмов, где они бы отрисовывались отфильтровываясь по категориям. * \\

'use strict';

const mainData = () => {
  const preloader = document.querySelector('.preloader');
  // Глобальный метод fetch() принимает первым обязательным аргументом строку URL, путь к тому файлу или к тому адресу из которого мы хотим достать какие-то данные. В нашем случае мы тянем данные из локального файла db.json.
  // Далее у этого метода построена последовательности специальных методов then(), данные методы будут запущены в тот момент, когда данные вернутся к нам от сервера. Эти методы принимают в себя callback-функцию. Метод then() запускают эту функцию тогда, когда данные полностью вернутся с сервера.
  // Если вывести получаемые данные объект response, то мы увидим, что они возвращаются в виде body: "ReadableStream". Это не те данные, которые мы бы хотели и с которыми можно работать. И для того, чтобы мы получили действительно подходящие для работы данные, то их необходимо прежде распаковать. Т.е. первый метод then() почти всегда будет возвращать тот же response, но обработанный методом json().
  // Следом идёт запуск ещё одного метода then(), ведь нам нужно убедится, что данные сперва полностью обработаны в json(). У него также есть callback-функция, и обработанные данные data будут переданы в этот callback.
  // ::===>
  // У каждого объекта есть свойство "views", т.е. кол-во просмотров. Всё, что нужно сделать это отсортировать наш массив с объектами фильмов по значению этого свойства и отобрать лишь первые 5 из них.
  // Чтобы отсортировать в порядке убывания используем "b.views - a.views".
  // Ну, а чтобы оставить лишь топ-5, а остальные убрать воспользуемся методом .slice(), который первым аргументом получит индекс в массиве, откуда начнёт "вырезать" кусок массива, а второй аргумент это индекс элемента в массиве до какого (не включительно) будет "обрезаться" массив.
  // Далее нам необходимо написать функцию, которая получит массив данных и, перебрав его, выведет в виде карточек в контейнер, который хранит "Top Views" список аниме фильмов. Назовём её renderTopAnime(). Туда же мы будем отправлять наши данные. [с. 55]
  // Теперь мы будем в этот контейнер "wrapper" методом перебора forEach() записывать [c.23] карточки из нашего массива. [c.55]
  // Сперва очистим все данные из нужного контейнера [c.21]. Для этого в свойство контейнера запишем пустую строку.

  // Итак для перебора коллекции мы также можем воспользоваться методом forEach(), но такой метод для коллекций немного иначе работает. Первый аргумент является итерируемым жанром, второй также, а третий это весь массив жанров в коллекции. Поэтому нам хватит только первого параметра.
  // А теперь нам необходимо выполнить довольно таки сложную структуру. Во-первых у нас есть перебор жанров, в котором мы могли бы вывести динамическую вёрстку сразу в блок контейнер. Но в каждом таком переборе нам необходимо ещё сделать перебор массива данных, отфильтровать по жанру необходимые аниме и добавить в каждый блок категории жанров. И на самом деле просто способ из renderTopAnime() нам не совсем подходит.
  // Сперва получим контейнер wrapper по классу "product-list", в котором у нас будут находиться все блоки категорий.
  const renderAnimeList = (array, genres) => {
    const wrapper = document.querySelector('.product-list');

    genres.forEach((genre) => {
      // Создаём пустой блок специальным методом document.createElement(). Теперь на каждой итерации будет создаваться элемент "div".
      const productBlock = document.createElement('div'); // это шапка блока со списком фильмов.
      // Создадим ещё один блок, в котором и будут лежать наши карточки.
      const listBlock = document.createElement('div');
      // Теперь внутри перебора наших жанров мы должны фильтровать наш array, т.е. доставать из массива только те данные, что подходят каждому итерированному жанру. Мы обратимся к нашему массиву и обработаем методом filter(). Мы будем получать item и оставлять только такой item, чей жанр равен жанру в нынешней итерации.
      const list = array.filter((item) => item.genre === genre);

      listBlock.classList.add('row');
      productBlock.classList.add('mb-5');

      // Добавим вёрстку карточек фильмов
      // Также разберёмся со ссылками "Посмотреть все", изначально мы переходили просто на categories.html, но нам необходимо ещё добавить какой-то параметр, по которому мы позже сможем понять какую именно категорию нам необходимо отрисовать. Итак допишем "?genre=${genre}", затем каждому конкретному аниме-фильму мы также добавим "?itemID=${item.id}"
      productBlock.insertAdjacentHTML(
        'beforeend',
        `
          <div class="row">
            <div class="col-lg-8 col-md-8 col-sm-8">
              <div class="section-title">
                <h4>${genre}</h4>
              </div>
            </div>
            <div class="col-lg-4 col-md-4 col-sm-4">
              <div class="btn__all">
                <a href="/categories.html?genre=${genre}" class="primary-btn">Посмотреть все <span class="arrow_right"></span></a>
              </div>
            </div>
          </div>
        `
      );
      // Теперь можем заняться перебором массива list.
      // Для добавления отметок с дополнительными жанрами нам понадобится добавлять дополнительно элемент ul. (подсмотрено из вёрстки) А дальше необходимо перебрать теги каждой карточки и внести необходимые <li>, т.е. теги.
      list.forEach((item) => {
        const tagsBlock = document.createElement('ul');

        item.tags.forEach((tag) =>
          tagsBlock.insertAdjacentHTML(
            'beforeend',
            `
              <li>${tag}</li>
            `
          )
        );

        // Здесь для вывода тегов жанров нам отлично подходи свойство объекта "outerHTML", которое берёт не только внутренности, но и внешний тег.
        listBlock.insertAdjacentHTML(
          'beforeend',
          `
            <div class="col-lg-4 col-md-6 col-sm-6">
              <div class="product__item">
                <div class="product__item__pic set-bg" data-setbg="${item.image}">
                  <div class="ep">${item.rating} / 10</div>
                  <div class="view"><i class="fa fa-eye"></i> ${item.views}</div>
                </div>
                <div class="product__item__text">
                  ${tagsBlock.outerHTML}
                  <h5><a href="/anime-details.html?itemID=${item.id}">${item.title}</a></h5>
                </div>
              </div>
            </div>
          `
        );
      });
      // А перед тем, как вставлять во wrapper productBlock мы добавим в него listBlock с карточками.
      productBlock.append(listBlock);
      // Но на странице этого блока ещё нет, добавим его при помощи метода .append()
      wrapper.append(productBlock);

      wrapper
        .querySelectorAll('.set-bg')
        .forEach(
          (element) =>
            (element.style.backgroundImage = `url('${element.dataset.setbg}')`)
        );
    });
    // Отключаем прелоадер.
    setTimeout(() => {
      preloader.classList.remove('active');
    }, 400);
  };

  const renderTopAnime = (array) => {
    const wrapper = document.querySelector('.filter__gallery');

    // Теперь запишем в контейнер вёрстку каждой карточки. Сделаем это методом insertAdjacentHTML(), где первым аргументом будет в каком порядке он будет отображать карточки или как он будет их туда размещать. У него есть 4 значение: ("beforeend, beforebegin, afterend, beforeend"). Вторым параметром идёт сама вёрстка.
    array.forEach((item) =>
      wrapper.insertAdjacentHTML(
        'beforeend',
        `
          <div class="product__sidebar__view__item set-bg mix" data-setbg="${item.image}">
            <div class="ep">${item.rating} / 10</div>
            <div class="view"><i class="fa fa-eye"></i> ${item.views}</div>
            <h5><a href="/anime-details.html">${item.title}</a></h5>
          </div>
        `
      )
    );

    wrapper
      .querySelectorAll('.set-bg')
      .forEach(
        (element) =>
          (element.style.backgroundImage = `url('${element.dataset.setbg}')`)
      );
  };

  // *[#3]* Меню в хедер с категориями. ***
  // Итак, после изучения вёрстки нам стало ясно, что кнопка Категорий состоит из списка <ul>, в котором <li> со ссылками <a> на какую-то конкретную категорию. Т.е. нам нужно создать список категорий в списке с классом "dropdown", который является выпадающим меню.
  // Также передадим в эту функцию все жанры.
  // Нужно и здесь сперва почистить всю вёрстку внутри, а затем сформировать перебором <li><a>%_Каждая категория_%</a></li>
  const renderGenresList = (genres) => {
    const dropdownMenu = document.querySelector('.header__menu .dropdown');

    genres.forEach((genre) =>
      dropdownMenu.insertAdjacentHTML(
        'beforeend',
        `<li><a href="./categories.html?genre=${genre}">${genre}</a></li>`
      )
    );
  };

  // *[#2]* Для второй задачи нам также необходимо выделить в массив все возможные жанры. Причём там должны быть только уникальные значения. Жанров всего 6. Нам нужно перебрать массив array и занести уникальные жанры в новый массив genres. Для это легче всего будет воспользоваться элементом коллекцией. Запишем в новую переменную genres "new Set()", что определит данную переменную как коллекцию. [с.53]
  // Далее перебираем весь массив наших аниме-фильмов. [c.57] Обратимся к genres методом add, который есть у коллекций. И таким образом заносим в эту коллекцию жанры "item.genre"
  // Теперь в genres находится коллекция уникальных жанров. Методы у коллекции уникальны и отличаются от массива и объекта. Коллекция "Set" позволяет нам создавать уникальные элементы в данной коллекции, т.е. в ней не могут повториться одинаковые значения. Если попадётся такое же значение при переборе, то оно просто перезапишется.
  // Её мы передадим в функцию renderAnimeList(), а также массив с аниме-фильмами data.anime.
  fetch('https://anime-site-777-default-rtdb.firebaseio.com/anime.json')
    .then((response) => response.json())
    .then((data) => {
      const genres = new Set();

      data.forEach((item) => genres.add(item.genre));

      renderTopAnime(data.sort((a, b) => b.views - a.views).slice(0, 5));
      renderAnimeList(data, genres);
      renderGenresList(genres);
    });
};

mainData();
